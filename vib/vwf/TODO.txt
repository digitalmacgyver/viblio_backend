PIPELINE STUFF:
3) Get face detection working on staging
4) Get face detection working on a different machine than staging
5) Get face detection working on 2 or moreprod machines

RECOGNIZE STUFF:
6) Install notify MTurk cron on a production box

FB STUFF:
1) Get web GUI firing messages into our thing.
2) Get it installed on staging / prod
3) Install PIL with pip install PIL on the machines where we will run the FB sync dealy.
4) Create CreateContacts.conf in config/*/*
5) Add CreateContacts to supervisor-*.conf

2) Discuss with Andy the data model - OK to just have picture URI and
nothing else? (Server crashes when I started making contacts that
weren't faces)

DB STUFF:
2) Disable video_dev_1, video_dev


ORPHAN FACES:

Wrapper that runs it once every 6 hours
Supervisor that owns it

Logic:
  Similar to MTurk notify
  select * from MAF where recognition_result is null and contact_id is null and created_date > 2 days old
  create new contacts
  make link

FACEBOOK INTEGRATION:

vib.fb.CreateContacts.py

run from supervisor

Objectives:

1) Create in Viblio a contact for each Facebook friend.

* Make query to Facebook, get friendlist.
* Check if this user already has any contacts with FBID - if so bail this is a one time operation at present
* For each friend, insert a contact with provider and FBID set.

2) Set an initial photo of each Facebook friend via rekognition.

Rekognition Tags are of form:
Name_With_Underscorres-FBID

* Execute Rekognition crawl
* Rename Recognized faces with just the FBID.
* For each tagged contact see if I can pull a face image out and store it is a new media type etc.

TOP LEVEL TODO:

1) Scalability: 

* Get 2 servers running Popeye in staging
* Get 2 servers running the rest of the pipeline in staging

On prod:

0) Upgrade boto on staging / prod
0) Install supervisor with easy_install

6) Add loggly logging.

7) We must manually set long timeouts on Face Recognition jobs that
are manual - we've set machine default type speeds in the pipeline
currently.

8) Extend logic: there are task fatal errors, and workflow fatal
errors.  We can decide to bail on a task (and everything after it), or
we can mark the dependent tree as completed?  Maybe it is better for
us to just have our application logic work such that this isn't
necessary.

9) Scale transcoder - does it become it's own service?  If so then
upload becomes it's own service.  Can we just scale popeye in some
stupid way for the time being?

9) Document the failure details = JSON with retry : true or false.  -
you can call self.fail with a reason (256 chars), and a details
(stringified JSON with a mandatory "retry" value which must be True or
False)

10) Use the best face confidence as the picture_uri.

--

Window 1:

import boto.swf.layer2 as swf
import json
import pprint
pp = pprint.PrettyPrinter( indent = 4 )

execution = swf.WorkflowType( name='VideoProcessingLocal', domain='Viblio', version='1.0.4' ).start( task_list='VPDeciderLocal', input = json.dumps( { 'media_uuid' : '1234', 'user_uuid' : '45567' } ) )

print pp.pprint( execution.history() )

Window 2-4

python -i VPDecider.py 
while VPDecider().run(): pass

python -i FaceDetect.py
while FaceDetect().run(): pass

python -i FaceRecognize.py
while FaceRecognize().run(): pass

==

FULL API DOCS:

http://docs.aws.amazon.com/amazonswf/latest/apireference/API_ActivityTaskCompletedEventAttributes.html
http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dev-about-workflows.html

DECISION TYPES:
http://docs.aws.amazon.com/amazonswf/latest/apireference/API_Decision.html

--

BUGS: 

1) Should pass KWargs from Layer2 constructor to Layer1?  Looks
like it might simply be a forgetful bug? 

If not, need a way to pass region through Layer2.

2) Domain class defaults retention to 30, no way to override it.

It's default should be the same as the AWS default, and should be a
configurable element.

3) activity / other Layer2 registrations shouldn't set defaults for
various timeouts.

4) Indentation in example with return True in decider.

5) The workflow_id generator will output duplicate workflow ids at the
same unix.time() - this can actually happen.

5) The simple demo assumes your decider is running before you start the task - otherwise the most recent task will be like DecisionTaskScheduled or something.

6) Docks say poll in activity task returns '' for taskToken when there
is nothing, but it doesn't, we get an empty dictionary.

7) Document that VPDecider assumes that each activity task is only run
once for a given workflow, our retry/timeout logic depends on this.

--

Eventually the task timed out (in this case task timeout was faster
than queue time out) and a new decision task is scheduled.  This
appears in the event history for the timeout:

    {   'activityTaskTimedOutEventAttributes': {   'scheduledEventId': 5,
                                                   'startedEventId': 6,
                                                   'timeoutType': 'START_TO_CLOSE'},
        'eventId': 7,
        'eventTimestamp': 1382306442.71,
        'eventType': 'ActivityTaskTimedOut'},

4) Get full flow for a workflow, not activity that times out.

When this happens, an event called: 'WorkflowExecutionTimedOut' as
added, and tha Workflow is moved to a status of CLOSED.  If the child
tasks tries to mark things as done they get a 400 Bad Request back
from the server.

5) What happens if a decider is killed while processing a thing?
The timeout and new decision event looks like:

    {   'decisionTaskTimedOutEventAttributes': {   'scheduledEventId': 2,
                                                   'startedEventId': 3,
                                                   'timeoutType': 'START_TO_CLOSE'},
        'eventId': 4,
        'eventTimestamp': 1382308347.929,
        'eventType': 'DecisionTaskTimedOut'},
    {   'decisionTaskScheduledEventAttributes': {   'startToCloseTimeout': '1',
                                                    'taskList': {   'name': 'TimeoutTest'}},
        'eventId': 5,
        'eventTimestamp': 1382308347.929,
        'eventType': 'DecisionTaskScheduled'}]

This can happen if you try to reschedule something with the same activityId:
    {   'eventId': 12,
        'eventTimestamp': 1382377765.197,
        'eventType': 'ScheduleActivityTaskFailed',
        'scheduleActivityTaskFailedEventAttributes': {   'activityId': 'FaceDetect-1234',
                                                         'activityType': {   'name': 'FaceDetect',
                                                                             'version': '1.0.4'},
                                                         'cause': 'ACTIVITY_ID_ALREADY_IN_USE',
                                                         'decisionTaskCompletedEventId': 10}},

--

Possible management tools: Chef, Puppet.

--

Logging and Metrics:

* In a queue model this is harder because the processing is distributed.

Groupon uses Splunk, but there is an open source alternative logstash.

There could also be third party solitions:

* Logly - log verbosely, times, durations, user_ids.  Push the
  complexity of analysis onto the logging solution.

-- 

For a queue based model, have a way to manually inject tasks into the
workflow for testing.


==== SAMPLE HISTORY WITH A DECISION TIMEOUT ==

>>> print pp.pprint( execution.history() )
[   {   'eventId': 1,
        'eventTimestamp': 1382306943.108,
        'eventType': 'WorkflowExecutionStarted',
        'workflowExecutionStartedEventAttributes': {   'childPolicy': 'TERMINATE',
                                                       'executionStartToCloseTimeout': '90',
                                                       'input': '{"media_uuid": "1234", "user_uuid": "45567"}',
                                                       'parentInitiatedEventId': 0,
                                                       'taskList': {   'name': 'TimeoutTest'},
                                                       'taskStartToCloseTimeout': '60',
                                                       'workflowType': {   'name': 'TimeoutTest',
                                                                           'version': '1.0'}}},
    {   'decisionTaskScheduledEventAttributes': {   'startToCloseTimeout': '60',
                                                    'taskList': {   'name': 'TimeoutTest'}},
        'eventId': 2,
        'eventTimestamp': 1382306943.108,
        'eventType': 'DecisionTaskScheduled'},
    {   'decisionTaskStartedEventAttributes': {   'scheduledEventId': 2},
        'eventId': 3,
        'eventTimestamp': 1382306943.152,
        'eventType': 'DecisionTaskStarted'},
    {   'decisionTaskTimedOutEventAttributes': {   'scheduledEventId': 2,
                                                   'startedEventId': 3,
                                                   'timeoutType': 'START_TO_CLOSE'},
        'eventId': 4,
        'eventTimestamp': 1382307003.155,
        'eventType': 'DecisionTaskTimedOut'},
    {   'decisionTaskScheduledEventAttributes': {   'startToCloseTimeout': '60',
                                                    'taskList': {   'name': 'TimeoutTest'}},
        'eventId': 5,
        'eventTimestamp': 1382307003.155,
        'eventType': 'DecisionTaskScheduled'},
    {   'decisionTaskStartedEventAttributes': {   'scheduledEventId': 5},
        'eventId': 6,
        'eventTimestamp': 1382307003.186,
        'eventType': 'DecisionTaskStarted'},
    {   'decisionTaskCompletedEventAttributes': {   'scheduledEventId': 5,
                                                    'startedEventId': 6},
        'eventId': 7,
        'eventTimestamp': 1382307013.374,
        'eventType': 'DecisionTaskCompleted'},
    {   'activityTaskScheduledEventAttributes': {   'activityId': 'activity id, an arbitrary string',
                                                    'activityType': {   'name': 'Upload',
                                                                        'version': '1.0.3'},
                                                    'decisionTaskCompletedEventId': 7,
                                                    'heartbeatTimeout': 'NONE',
                                                    'input': '{"arbitrary": ["string", "we", "use", "json"]}',
                                                    'scheduleToCloseTimeout': '1260',
                                                    'scheduleToStartTimeout': '1260',
                                                    'startToCloseTimeout': '60',
                                                    'taskList': {   'name': 'UploadTask'}},
        'eventId': 8,
        'eventTimestamp': 1382307013.374,
        'eventType': 'ActivityTaskScheduled'},
    {   'activityTaskStartedEventAttributes': {   'scheduledEventId': 8},
        'eventId': 9,
        'eventTimestamp': 1382307020.434,
        'eventType': 'ActivityTaskStarted'},
    {   'activityTaskCompletedEventAttributes': {   'result': '["we", "also", "return json"]',
                                                    'scheduledEventId': 8,
                                                    'startedEventId': 9},
        'eventId': 10,
        'eventTimestamp': 1382307025.542,
        'eventType': 'ActivityTaskCompleted'},
    {   'decisionTaskScheduledEventAttributes': {   'startToCloseTimeout': '60',
                                                    'taskList': {   'name': 'TimeoutTest'}},
        'eventId': 11,
        'eventTimestamp': 1382307025.542,
        'eventType': 'DecisionTaskScheduled'},
    {   'decisionTaskStartedEventAttributes': {   'scheduledEventId': 11},
        'eventId': 12,
        'eventTimestamp': 1382307025.574,
        'eventType': 'DecisionTaskStarted'},
    {   'decisionTaskCompletedEventAttributes': {   'scheduledEventId': 11,
                                                    'startedEventId': 12},
        'eventId': 13,
        'eventTimestamp': 1382307025.892,
        'eventType': 'DecisionTaskCompleted'},
    {   'eventId': 14,
        'eventTimestamp': 1382307025.892,
        'eventType': 'WorkflowExecutionCompleted',
        'workflowExecutionCompletedEventAttributes': {   'decisionTaskCompletedEventId': 13}}]
None
