ROLLOUT PROCEDURE:
1. Shut down web servers.
2. Make a backup of database.
3. Run serialize on the copy database.
4. Run DB creation scripts.
5. Edit populate to have update_recognition = True, single_user = None
6. Run populate on the target data.
7. Revoke permissions on old schema.

revoke all on video_dev_1.* from 'web_dev', 'vwf_dev', 'popeye_dev';

8. Rename old tables in new schema.

alter table contacts rename deprecated_contacts;
alter table contact_groups rename deprecated_contact_groups;
alter table media_shares rename deprecated_media_shares;
alter table communities rename deprecated_communities;
alter table media_asset_features change contact_id deprecated_contact_id int;

9. Bring up new software and test.

TODO:

5. Re-implement back end to do the right stuff.

grep for: 

grep -ir contacts * | cut -d ':' -f1 | sort -u | grep -v "Binary file" | grep -v '\~'

TEST: cv/FaceRecognition/CleanupFaces.py

* DO NOT TEST TILL EVERYTING IS PORTED, OR IT WILL WIPE OUT
  RECOGNITION!

TEST: utils/greet_new_users.py

* Used similar logic to this all over.
* Did some initial testing.

TEST: fb/CreateContacts.py

* Include test case of two people adding the same FB contact, it
  should result in only one new user.
* Did some initial testing

TEST: utils/rescue_orphan_faces.py

* Did some initial testing.

TEST: utils/delete_user.py

* Did some initial testing.

TEST: vwf/FaceRecognize/db_utils.py, vwf/FaceRecognize/Recognize.py

* Did some initial testing - retest.

DEPRECATED / FIX LATER:
utils/clone_user.py
utils/manage_demo_accounts.py
utils/person_summary.py
utils/test.py

DONE:
grep -ir media_share * | cut -d ':' -f1 | sort -u | grep -v "Binary file" | grep -v '\~'
grep -ir community * | cut -d ':' -f1 | sort -u | grep -v "Binary file" | grep -v '\~'
grep -ir communities * | cut -d ':' -f1 | sort -u | grep -v "Binary file" | grep -v '\~'
grep -ir is_group * | cut -d ':' -f1 | sort -u | grep -v "Binary file" | grep -v '\~'
grep -ir organization_users * | cut -d ':' -f1 | sort -u | grep -v "Binary file" | grep -v '\~'
grep -ir media_share_id * | cut -d ':' -f1 | sort -u | grep -v "Binary file" | grep -v '\~'
grep -ir member_id * | cut -d ':' -f1 | sort -u | grep -v "Binary file" | grep -v '\~'
grep -ir members_id * | cut -d ':' -f1 | sort -u | grep -v "Binary file" | grep -v '\~'
grep -ir curators_id * | cut -d ':' -f1 | sort -u | grep -v "Binary file" | grep -v '\~'
grep -ir share_type * | cut -d ':' -f1 | sort -u | grep -v "Binary file" | grep -v '\~'
grep -ir view_count *  | cut -d ':' -f1 | sort -u | grep -v "Binary file" | grep -v '\~'

Sample queries:

Note - the samples below have select * - but in reality we should pare
it down to just the columns the UI cares about.

All videos I own:
=================

Same as today - however the back end will also maintain a special
album called "My Videos" with is_viblio_created = 1 for each user that
has all the videos they upload.

All media/face/tag/etc information in videos I own (NULLs if there is no data):
===============================================================================

select *
from media inner join media_assets on media.id = media_assets.media_id
inner join media_asset_features on media_assets.media_id = media_asset_features.media_id
and media.user_id = 114
left outer join users on media_asset_features.face_user_id = users.id;

All contacts for user X.
========================

select * 
from user_groups, users
where user_groups.member_id = users.id
and owner_id = 114
and member_role = 'contact';

A list of "Friends of friends" to populate drop downs with when people to go tag faces:
=======================================================================================

Note: the search here returns:
* Any contacts of the current user
* Any contacts of any user that the current user has shared to
* Any contacts of any user that has shared to the current user

select distinct( users.id ), users.email, member_name
from user_groups, users
where user_groups.member_id = users.id
and member_role = 'contact'
and owner_id in (
  select 114 as owner_id from dual
  union
  select users.id as owner_id
  from user_groups, users
  where user_groups.member_id = users.id
  and owner_id = 114
  and member_role in ( 'viewer', 'editor', 'admin' )
  union
  select users.id as owner_id
  from user_groups, users
  where user_groups.owner_id = users.id
  and user_groups.member_id = 114
  and member_role in ( 'viewer', 'editor', 'admin' ) )
and ( displayname is not null or ( owner_id = 114 and member_name is not null ) )
group by users.id;


Queries related to all videos shared with me:
====================================================================================

All information about videos shared with me, including faces and tags:
select *
from user_groups inner join shared_album_groups on user_groups.group_id = shared_album_groups.members_id
inner join media_albums on shared_album_groups.media_id = media_albums.album_id
inner join media on media_albums.media_id = media.id
inner join media_assets on media.id = media_assets.media_id
inner join media_asset_features on media_assets.media_id = media_asset_features.media_id
and member_id = 114
and member_role in ( 'viewer', 'editor', 'admin' )
left outer join users on media_asset_features.face_user_id = users.id;

Media assets associated with media in albums shared to groups user X is in:
select *
from user_groups, shared_album_groups, media_albums, media, media_assets
where user_groups.group_id = shared_album_groups.members_id
and shared_album_groups.media_id = media_albums.album_id
and media_albums.media_id = media.id
and media.id = media_assets.media_id
and member_id = 114
and member_role in ( 'viewer', 'editor', 'admin' );

Share groups user X is in:
select *
from user_groups
where member_id = 114
and member_role in ( 'viewer', 'editor', 'admin' );

Shares made to groups user X is in:
select *
from user_groups, shared_album_groups
where user_groups.group_id = shared_album_groups.members_id
and member_id = 114
and member_role in ( 'viewer', 'editor', 'admin' );

Albums shared to groups user X is in:
select *
from user_groups, shared_album_groups, media_albums
where user_groups.group_id = shared_album_groups.members_id
and shared_album_groups.media_id = media_albums.album_id
and member_id = 114
and member_role in ( 'viewer', 'editor', 'admin' );

Media in albums shared to groups user X is in:
select *
from user_groups, shared_album_groups, media_albums, media
where user_groups.group_id = shared_album_groups.members_id
and shared_album_groups.media_id = media_albums.album_id
and media_albums.media_id = media.id
and member_id = 114
and member_role in ( 'viewer', 'editor', 'admin' );

Media asset features associated with media assets ... for user x:
select *
from user_groups, shared_album_groups, media_albums, media, media_assets, media_asset_features
where user_groups.group_id = shared_album_groups.members_id
and shared_album_groups.media_id = media_albums.album_id
and media_albums.media_id = media.id
and media.id = media_assets.media_id
and media_assets.media_id = media_asset_features.media_id
and member_id = 114
and member_role in ( 'viewer', 'editor', 'admin' );

Top Actors Query:
=================

select users.id, count( distinct( media_id ) )
from users, media_asset_features
where users.id = media_asset_features.face_user_id
and media_asset_features.user_id = 114
group by users.id;

Creating a user - after standard user creation, create the following records:
=============================================================================

* The special "Contacts" group for that user:
insert into groups ( owner_id, uuid, group_type, group_name ) values ( X, Y, 'contact', 'Contacts' );

* The special "My Videos album for that user:
insert into media ( user_id, uuid, media_type, is_album, display_album, title, is_viblio_created ) values ( X, Y, 'original', 1, 1, 'My Videos', 1 );

Adding a contact to a user:
===========================

* If the contact has an email address, see if there is already a user
  in users with that email.  Otherwise create a new user of type 'contact':
insert into users ( uuid, email, displayname, user_type ) values ( X, Y, Z, 'contact' );

* Determine the Groups.id of the special "contacts" group owned by the user in question: GID
insert into groups ( group_id, owner_id, member_id, uuid, member_name, member_role, picture_uri ) values ( GID, ID_OF_ACTIVE_USER, ID_OF_USER_CREATED_OR_SELECTED_ABOVE, X, Y, 'contact', Z );

Creating a share:
=================

* To create a potential / public / hidden share for media MID, user UID:
insert into shared_album_groups ( user_id, uuid, share_type, media_id, is_curated ) values ( UID, X, 'potential/public/hidden', MID, 0 );

* To create a shared album AKA community:
  + Determine if the selected set of users the share will go to
    already exists as a share group, if so call this GID, otherwise:
    + For each email to share to, check if there is already a user with that email, if not create on as described above in "adding a contact to a user"
    + Create a share group for this set of users with emails:
insert into groups ( owner_id, uuid, group_type, group_name ) values ( ACTIVE_USER, X, 'share', Y );
    + Add each user to this share group with:
insert into user_groups ( group_id, owner_id, member_id, uuid, member_name, member_role ) values ( GROUP_FROM_LAST_STEP, ACTIVE_USER, EMAIL_USER, X, ?TBD?, 'editor' )
  + Associate an album AID with the group GID created above:
insert into shared_album_groups ( user_id, uuid, share_type, media_id, members_id, is_curated ) values ( UID, X, 'private', AID, GID, 0 );

TBD: Getting the name for a user.

Each contact is a mapping to a user, each user has a displayname.
Each user_group 'contact' mapping also has a member_name.  This allows
us to have nicknames for users, and for each user to pick the picture
they want associated with another user who appears in their videos.

So - we have to make a choice about how to display names for contacts
- we could use a nickname system, or a single name for any email, or
some hybrid approach depending on whether the user in question has
logged into their Viblio account.



6. Implement a cleanup tool to take out:

A. 'contact' users with no email or facebook ID and no mapping to user_groups.
B. 'contact' user_group records for users that have no associated email or name, and no MAF entries for that user.
C. Decide whether or not to delete FR stuff when we do this too.

8. Test in staging:

9. BEFORE ACTUAL ROLLOUT, CHANGE UPDATE_RECOGNITION TO TRUE IN POPULATE_USER_GROUPS.

9. IMPORTANT - ONCE EVERTYHING IS WORKING UPDATE MAF.CONTACT_ID to be
NULL SO WHEN WE DELETE CONTACTS WE DON'T CASCADE DOWN DELETE ALL THE
MAFS.

IN THE NEARER TERM, WE CAN DROP THE FK.





select * from communities where user_id = 482;

select media.id, media_shares.id, media_shares.user_id, contact_id, title, share_type, is_album from media_shares, media where media.user_id = 482 and media_shares.media_id = media.id;

-- Contact groups
select * from contacts where id in ( select members_id from communities where user_id = 482 );

-- Group members
select * from contacts where id in ( select contact_id from contact_groups where group_id in ( select members_id from communities where user_id = 482 ) );

mjhayward@gmail.com - full user

CASES:

1 - share to full user from album detail.

Shared to mjhayward@gmail.com.

a. Popping up the share dialog doesn't create a potential share.
b. After closing the dialog:

a community is created
a contact is created
a contact group is created with contact_name of AlbumName + community_id
the contact is placed in that contact group.

c. When that contact views the share:

No additional rows are created.

2 - share to full user from videos->albums.

Same as above.

3 - share to new user from album detail.

mjhayward+new123@gmail.com

This has caused a new row to show up in media shares like:

+------+--------------------------------------+----------+---------+------------+------------+----------------+------------+---------------------+--------------+
| 1308 | 58073858-FE86-11E3-B5B3-4690918B7424 |     6510 |     497 |       NULL | private    |              0 |       NULL | 2014-06-28 05:37:50 | NULL         |
+------+--------------------------------------+----------+---------+------------+------------+----------------+------------+---------------------+--------------+


CHALLENGES:

1) What rights do we want users to have on shared albums - viewer,
editor, admin, owner?

2) The UI frequently wants to see "all videos I can see" - how is this
query done?

QUESTION: We we need a distinct groups and user_groups table, or is
just user_groups onto users sufficient?

All my shared content in the "groups, user_groups" scenario:

select *
from media, media_shares, media_albums, groups, user_groups
where user_groups.member_id = 'my user id'
and user_groups.group_id = groups.id
and groups.id = media_shares.members_id
and media_albums.album_id = media_shares.media_id
and media_albums.media_id = media.id

Wow this is a bad query, and further we're doing something fishy in
joinin gfrom media_albums to media_shares.  Think if maybe the
album_id shouldn't be the FK into the media_shares table instead.

DEBUG - IF YOU CAN ONLY SHARE AN ALBUM, IT'S BAD FORM TO FK MEDIA.ID
INTO COMMUNITIES.  ON THE OTHER HAND, IT's NICE THAT ALBUMS HAVE ALL
THE CHARACTERISTICS OF MEDIA - ASSETS AND THE LIKE, SO BREAKING OUT
INTO ALBUMS AND MEDIA MIGHT BE A PROBLEM.


Order 10s of millions to billions of rows in the fulapt-get install neo4jl cartesian join.


How could we unwind it:

Each user has a list of content they are allowed to see.  When a share
happens those users get added to the list.



All my shared content in the "user_groups" only scenario:

select * 
from media, media_shares, media_albums, user_groups
where user_groups.member_id = my user id
and user_groups.groups_id = media_shares.members_id
and ...

Well - one less table.

What is user_groups and groups getting us?

It means we don't end up with "is_group" rows in the users table, or
"user" libe objects that are just containers for groups of users,
which are in reality owned by other users.


--

1) organization_users - this table is not used in production or dev.

2) user_roles - this table is not used in production, in dev it has one
row mapping vaadmin@viblio.com to the admin role. 

This seems to be vestigal from the old "communities" project?

3) user_types - this table was used to specify users as being
"organization" users or "individuals."  Currently there are no
"organization" users in development or production.

4) contact_groups - There are a limited number (~100 prod, ~23 dev) of
contact groups.  None have the contact_viblio_id set.

These contact groups seem to relate to shared albums, in the
"communities" sense.

The "provider_id" column of contacts is set to _shared_album in some
cases.

A particular contact group is 17976 contact_id - Kairo Orange Belt test21.

5) media_share_messages is not currently populated in development or prod.

6) Communities are used a bit (<20) in development and prod, they seem
to implement the "Shared group album" feature.

The "member_id" column of a community album is the contact_group ID of
a shared album it appears.

All the "media_id" of communities are "album" type media rows.

7) media_shares are widely used (hundreds of rows in each).

--

CREATE SCHEMA IF NOT EXISTS `video_dev_2` DEFAULT CHARACTER SET utf8 COLLATE utf8_bin ;
use video_dev_2;

=====


grant select, insert, update, delete, create temporary tables, lock tables, execute, trigger on video_dev_2.* to 'web_dev' with max_user_connections 200;

grant select, insert, update, delete, create temporary tables, lock tables, execute, trigger on video_dev_2.* to 'vwf_dev' with max_user_connections 200;

grant select, insert, update, delete, create temporary tables, lock tables, execute, trigger on video_dev_2.* to 'popeye_dev' with max_user_connections 200;



4. Remove access to contacts, contact_groups, media_shares, communities.

-- To avoid namespace collisions with recognition, we need to bump our
-- users id up above the top possible contact so far.

select max( id ) from contacts;
select max( id ) from users;

alter table users auto_increment = XXX;


--

drop table organization_users;
drop table user_roles;

update contacts set contact_email = null where contact_email = 'feedback@viblio.com';

insert into user_types ( type ) values ( 'contact' );

alter table media add column display_album bool not null default true after is_album;

-- Create group_types, groups, user_groups:

CREATE  TABLE IF NOT EXISTS `group_types` (
  `type` VARCHAR(32) NOT NULL ,
  `created_date` DATETIME NULL DEFAULT NULL ,
  `updated_date` DATETIME NULL DEFAULT NULL ,
  PRIMARY KEY (`type`) )
ENGINE = InnoDB;

-- Trigger DDL Statements
DELIMITER $$

CREATE
	TRIGGER group_type_created BEFORE INSERT ON group_types FOR EACH ROW
BEGIN
	set NEW.created_date = NOW();
END;
$$

CREATE
	TRIGGER group_type_updated BEFORE UPDATE ON group_types FOR EACH ROW
BEGIN
	set NEW.updated_date = NOW();
END;
$$

DELIMITER ;

insert into group_types ( type ) values ( 'contact' );
insert into group_types ( type ) values ( 'share' );
commit;


CREATE  TABLE IF NOT EXISTS `groups` (
  `id` INT NOT NULL AUTO_INCREMENT ,
  `owner_id` INT(11) NOT NULL ,
  `uuid` VARCHAR(36) NOT NULL ,
  `group_type` VARCHAR(32) NOT NULL ,
  `group_name` VARCHAR(128) NULL ,
  `organization_uid` VARCHAR(128) NULL ,
  `created_date` DATETIME NULL ,
  `updated_date` DATETIME NULL ,
  PRIMARY KEY (`id`) ,
  INDEX `fk_groups_users1` (`owner_id` ASC) ,
  INDEX `fk_groups_group_types1` (`group_type` ASC) ,
  INDEX `fk_groups_user_groups1` (`id` ASC, `owner_id` ASC) ,
  UNIQUE INDEX `uuid_UNIQUE` (`uuid` ASC) ,
  CONSTRAINT `fk_groups_users1`
    FOREIGN KEY (`owner_id` )
    REFERENCES `users` (`id` )
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `fk_groups_group_types1`
    FOREIGN KEY (`group_type` )
    REFERENCES `group_types` (`type` )
    ON DELETE RESTRICT
    ON UPDATE RESTRICT)
ENGINE = InnoDB;

-- Trigger DDL Statements
DELIMITER $$



CREATE
	TRIGGER group_created BEFORE INSERT ON groups FOR EACH ROW
BEGIN
	set NEW.created_date = NOW();
END;
$$

CREATE
	TRIGGER group_updated BEFORE UPDATE ON groups FOR EACH ROW
BEGIN
	set NEW.updated_date = NOW();
END;
$$

DELIMITER ;


CREATE  TABLE IF NOT EXISTS `user_groups` (
  `id` INT(11) NOT NULL AUTO_INCREMENT ,
  `group_id` INT NOT NULL ,
  `owner_id` INT(11) NOT NULL ,
  `member_id` INT(11) NOT NULL ,
  `uuid` VARCHAR(36) NOT NULL ,
  `member_name` VARCHAR(128) NULL DEFAULT NULL ,
  `member_role` VARCHAR(32) NULL DEFAULT NULL ,
  `picture_uri` VARCHAR(2048) NULL DEFAULT NULL ,
  `created_date` DATETIME NULL DEFAULT NULL ,
  `updated_date` DATETIME NULL DEFAULT NULL ,
  PRIMARY KEY (`id`) ,
  INDEX `fk_user_groups_users1` (`member_id` ASC) ,
  UNIQUE INDEX `uuid_UNIQUE` (`uuid` ASC) ,
  INDEX `fk_user_groups_groups1` (`group_id` ASC, `owner_id` ASC) ,
  CONSTRAINT `fk_user_groups_users1`
    FOREIGN KEY (`member_id` )
    REFERENCES `users` (`id` )
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_user_groups_groups1`
    FOREIGN KEY (`group_id` , `owner_id` )
    REFERENCES `groups` (`id` , `owner_id` )
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB;

-- Trigger DDL Statements
DELIMITER $$

CREATE
	TRIGGER user_group_created BEFORE INSERT ON user_groups FOR EACH ROW
BEGIN
	set NEW.created_date = NOW();
END;
$$

CREATE
	TRIGGER user_group_updated BEFORE UPDATE ON user_groups FOR EACH ROW
BEGIN
	set NEW.updated_date = NOW();
END;
$$

DELIMITER ;


CREATE  TABLE IF NOT EXISTS `shared_album_groups` (
  `id` INT NOT NULL AUTO_INCREMENT ,
  `user_id` INT(11) NOT NULL ,
  `uuid` VARCHAR(36) NOT NULL ,
  `name` VARCHAR(128) NULL DEFAULT NULL ,
  `share_type` VARCHAR(16) NOT NULL ,
  `media_id` INT(11) NOT NULL ,
  `pending_id` INT(11) NULL DEFAULT NULL ,
  `members_id` INT(11) NULL DEFAULT NULL ,
  `curators_id` INT(11) NULL DEFAULT NULL ,
  `is_curated` TINYINT(1) NOT NULL DEFAULT true ,
  `webhook` TEXT NULL DEFAULT NULL ,
  `created_date` DATETIME NULL DEFAULT NULL ,
  `updated_date` DATETIME NULL DEFAULT NULL ,
  PRIMARY KEY (`id`, `user_id`) ,
  INDEX `fk_shared_albums_users1` (`user_id` ASC) ,
  INDEX `fk_shared_albums_groups1` (`members_id` ASC) ,
  INDEX `fk_shared_albums_groups2` (`curators_id` ASC) ,
  INDEX `fk_shared_albums_groups_media1` (`media_id` ASC) ,
  INDEX `fk_shared_albums_groups_media2` (`pending_id` ASC) ,
  UNIQUE INDEX `uuid_UNIQUE` (`uuid` ASC) ,
  INDEX `fk_shared_album_groups_share_types1` (`share_type` ASC) ,
  CONSTRAINT `fk_shared_albums_users1`
    FOREIGN KEY (`user_id` )
    REFERENCES `users` (`id` )
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `fk_shared_albums_groups1`
    FOREIGN KEY (`members_id` )
    REFERENCES `groups` (`id` )
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `fk_shared_albums_groups2`
    FOREIGN KEY (`curators_id` )
    REFERENCES `groups` (`id` )
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `fk_shared_albums_groups_media1`
    FOREIGN KEY (`media_id` )
    REFERENCES `media` (`id` )
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `fk_shared_albums_groups_media2`
    FOREIGN KEY (`pending_id` )
    REFERENCES `media` (`id` )
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT `fk_shared_album_groups_share_types1`
    FOREIGN KEY (`share_type` )
    REFERENCES `share_types` (`type` )
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- Trigger DDL Statements
DELIMITER $$

CREATE
	TRIGGER shared_album_group_created BEFORE INSERT ON shared_album_groups FOR EACH ROW
BEGIN
	set NEW.created_date = NOW();
END;
$$

CREATE
	TRIGGER shared_album_group_updated BEFORE UPDATE ON shared_album_groups FOR EACH ROW
BEGIN
	set NEW.updated_date = NOW();
END;
$$

DELIMITER ;

alter table media_share_messages drop foreign key fk_media_share_messages_media_shares1;
alter table media_share_messages drop foreign key fk_media_share_messages_contacts1;
alter table media_share_messages drop index fk_media_share_messages_media_shares1;
alter table media_share_messages drop index fk_media_share_messages_contacts1;
alter table media_share_messages change contact_id user_id int;
alter table media_share_messages change media_share_id shared_album_group_id int;
alter table media_share_messages add INDEX `fk_media_share_messages_shared_albums1` (`shared_album_group_id` ASC, `user_id` ASC);
alter table media_share_messages add  CONSTRAINT `fk_media_share_messages_shared_albums1`
    FOREIGN KEY (`shared_album_group_id` , `user_id` )
    REFERENCES `shared_album_groups` (`id` , `user_id` )
    ON DELETE CASCADE
    ON UPDATE CASCADE;

alter table media_asset_features add column face_user_id int null default null after feature_type;
alter table media_asset_features add INDEX `fk_media_asset_features_users1` (`face_user_id` ASC);
alter table media_asset_features add CONSTRAINT `fk_media_asset_features_users1`
    FOREIGN KEY (`face_user_id` )
    REFERENCES `users` (`id` )
    ON DELETE SET NULL
    ON UPDATE SET NULL;




-- END OF TIME CLEANUP
-- drop table communities;
-- drop table media_shares;
-- update media_asset_features set contact_id = null;
-- alter table media_asset_features drop foreign key fk_media_asset_features_contacts1;
-- alter table media_asset_features drop index fk_media_asset_features_contacts1;
-- alter table media_asset_features drop column contact_id;
-- drop table contact_groups;
-- drop table contacts;
